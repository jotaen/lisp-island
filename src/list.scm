(define (empty? xs) (= 0 (length xs)))

(define (compose . fs)
  (lambda (x) (fold-right (lambda (f x) (f x)) x fs)))

(define (sort-pair p) (if (> (first p) (second p)) (reverse p) p))

(define (slice xs start end)
  (define (slice-iter head tail result)
    (if (not (= start (length head)))
      (slice-iter (append head (list (first tail))) (cdr tail) result)
      (let ((size (- end start)))
        (if (= size (length result))
          result
          (slice-iter head (cdr tail) (append result (list (first tail))))))))
  (slice-iter '() xs '()))

(define (insert-sort numbers)
  (define (sort-into-iter x smaller larger)
    (if (or (empty? larger) (<= x (car larger)))
      (append smaller `(,x) larger)
      (sort-into-iter x (append smaller `(,(car larger))) (cdr larger))))
  (define (sort-into x sorted) (sort-into-iter x '() sorted))
  (define (sort-iter unsorted sorted)
    (if (empty? unsorted)
      sorted
      (sort-iter (cdr unsorted) (sort-into (car unsorted) sorted))))
  (sort-iter numbers '()))

(define (select-sort numbers)
  (define (find-smallest-iter left right candidate)
    (if (empty? left)
      `(,candidate ,right)
      (let* ((n (car left)) (smaller (min candidate n)) (bigger (max candidate n)))
        (find-smallest-iter (cdr left) (cons bigger right) smaller))))
  (define (find-smallest xs) (find-smallest-iter (cdr xs) '() (car xs)))
  (define (sort-iter unsorted sorted)
    (if (>= 1 (length unsorted))
      (append sorted unsorted)
      (let* (
        (p (find-smallest unsorted))
        (smallest (first p))
        (remainder (second p)))
          (sort-iter remainder (append sorted `(,smallest))))))
  (sort-iter numbers '()))
